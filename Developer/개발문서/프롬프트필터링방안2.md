# PromptGate ëª¨ë“ˆ ìƒì„¸ ì„¤ê³„ì„œ

## 1. ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### 1.1 ì „ì²´ êµ¬ì„±ë„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Client App    â”‚â”€â”€â”€â–¶â”‚           PromptGate Proxy           â”‚â”€â”€â”€â–¶â”‚  LLM Backendâ”‚
â”‚                 â”‚    â”‚                                      â”‚    â”‚  (GPT/etc)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                       â”‚              â”‚              â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚Policy Engineâ”‚ â”‚Vector DB  â”‚ â”‚Audit Logger â”‚
                â”‚    (OPA)    â”‚ â”‚(Qdrant)   â”‚ â”‚(OpenSearch) â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 í”„ë¡œì„¸ì‹± íŒŒì´í”„ë¼ì¸
```
[Input] â†’ [Auth] â†’ [Normalize] â†’ [Filter Stack] â†’ [Sanitize] â†’ [LLM] â†’ [Output Filter] â†’ [Response]
                                      â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                 â”‚                 â”‚
            [Static Filter]  [ML Classifier]  [Embedding Filter]
                    â”‚                 â”‚                 â”‚
            [Secret Scanner] [PII Detector]  [Injection Detector]
```

## 2. í•µì‹¬ ì»´í¬ë„ŒíŠ¸ ì„¤ê³„

### 2.1 ì¸ì¦ ë° ë¼ìš°íŒ… ë ˆì´ì–´
```python
@dataclass
class RequestContext:
    tenant_id: str
    user_id: str
    session_id: str
    request_id: str
    timestamp: datetime
    client_ip: str
    user_agent: str
    
class AuthenticationHandler:
    async def authenticate(self, request: Request) -> RequestContext:
        # JWT/API Key ê²€ì¦
        # í…Œë„ŒíŠ¸/ì‚¬ìš©ì ì‹ë³„
        # RBAC ê¶Œí•œ í™•ì¸
        pass
```

### 2.2 ì •ì±… ì—”ì§„ (OPA ê¸°ë°˜)
```python
class PolicyEngine:
    def __init__(self):
        self.opa_client = OPAClient()
        self.policies = {}
    
    async def evaluate(self, context: RequestContext, prompt: str) -> PolicyResult:
        """
        Rego ì •ì±… í‰ê°€:
        - í…Œë„ŒíŠ¸ë³„ ê·œì¹™ ì ìš©
        - ì‚¬ìš©ì ê¶Œí•œ ì²´í¬
        - ì»¨í…ì¸  ë¶„ë¥˜ ê²°ê³¼ ë°˜ì˜
        """
        input_data = {
            "tenant": context.tenant_id,
            "user": context.user_id,
            "prompt": prompt,
            "metadata": self.extract_metadata(prompt)
        }
        return await self.opa_client.query("data.promptgate.allow", input_data)

# Rego ì •ì±… ì˜ˆì‹œ
```
package promptgate

default allow = false

allow {
    input.tenant == "kra-internal"
    not contains_secrets(input.prompt)
    not contains_injection(input.prompt)
    user_has_permission(input.user)
}

contains_secrets(prompt) {
    regex.match("(?i)password|secret|token", prompt)
}
```

### 2.3 í•„í„° ìŠ¤íƒ êµ¬í˜„

#### Static Pattern Filter
```python
class StaticPatternFilter:
    def __init__(self, config: Dict):
        self.deny_patterns = [re.compile(p, re.IGNORECASE) for p in config.get("deny_patterns", [])]
        self.vectorscan = load_vectorscan_db(config.get("pattern_db"))
    
    async def filter(self, prompt: str) -> FilterResult:
        # Regex íŒ¨í„´ ë§¤ì¹­
        for pattern in self.deny_patterns:
            if pattern.search(prompt):
                return FilterResult(
                    action="block",
                    reason="matched_deny_pattern",
                    confidence=1.0
                )
        
        # Vectorscan ê³ ì„±ëŠ¥ íŒ¨í„´ ë§¤ì¹­
        matches = self.vectorscan.scan(prompt)
        if matches:
            return FilterResult(action="block", reason="vectorscan_match")
        
        return FilterResult(action="allow")
```

#### Secret Scanner
```python
class SecretScanner:
    def __init__(self):
        self.detectors = [
            AWSKeyDetector(),
            JWTDetector(),
            PasswordDetector(),
            KoreanNationalIDDetector()
        ]
    
    async def scan(self, prompt: str) -> List[SecretMatch]:
        results = []
        for detector in self.detectors:
            matches = await detector.detect(prompt)
            results.extend(matches)
        return results

class AWSKeyDetector:
    pattern = re.compile(r'AKIA[0-9A-Z]{16}')
    
    async def detect(self, text: str) -> List[SecretMatch]:
        matches = []
        for match in self.pattern.finditer(text):
            matches.append(SecretMatch(
                type="aws_access_key",
                value=match.group(),
                start=match.start(),
                end=match.end(),
                confidence=0.95
            ))
        return matches
```

#### PII Detector (Presidio ì—°ë™)
```python
class PIIDetector:
    def __init__(self):
        self.analyzer = AnalyzerEngine()
        self.anonymizer = AnonymizerEngine()
        
        # í•œêµ­ì–´ PII íŒ¨í„´ ì¶”ê°€
        korean_patterns = [
            Pattern(name="KR_RRN", regex=r'\d{6}-[1-4]\d{6}', score=0.9),  # ì£¼ë¯¼ë²ˆí˜¸
            Pattern(name="KR_PHONE", regex=r'01[016789]-\d{3,4}-\d{4}', score=0.8)  # íœ´ëŒ€í°
        ]
        self.analyzer.registry.add_recognizer(PatternRecognizer("KR_CUSTOM", patterns=korean_patterns))
    
    async def detect(self, text: str) -> List[PIIMatch]:
        results = self.analyzer.analyze(text=text, language='ko')
        return [PIIMatch.from_presidio(r) for r in results]
    
    async def anonymize(self, text: str, pii_matches: List[PIIMatch]) -> str:
        anonymized = self.anonymizer.anonymize(
            text=text,
            analyzer_results=[m.to_presidio() for m in pii_matches],
            operators={"DEFAULT": OperatorConfig("replace", {"new_value": "[REDACTED]"})}
        )
        return anonymized.text
```

#### ML ê¸°ë°˜ ë¶„ë¥˜ê¸°
```python
class MLPromptClassifier:
    def __init__(self, model_path: str):
        self.tokenizer = AutoTokenizer.from_pretrained(model_path)
        self.model = AutoModelForSequenceClassification.from_pretrained(model_path)
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.model.to(self.device)
    
    async def classify(self, prompt: str) -> ClassificationResult:
        """
        ë¶„ë¥˜ ì¹´í…Œê³ ë¦¬:
        - safe: ì•ˆì „í•œ í”„ë¡¬í”„íŠ¸
        - injection: í”„ë¡¬í”„íŠ¸ ì¸ì ì…˜ ì‹œë„
        - harmful: ìœ í•´ ì»¨í…ì¸ 
        - sensitive: ë¯¼ê° ì •ë³´ ì²˜ë¦¬
        """
        inputs = self.tokenizer(prompt, return_tensors="pt", truncation=True, max_length=512)
        inputs = {k: v.to(self.device) for k, v in inputs.items()}
        
        with torch.no_grad():
            outputs = self.model(**inputs)
            probabilities = torch.softmax(outputs.logits, dim=-1)
            
        predicted_class = torch.argmax(probabilities, dim=-1).item()
        confidence = probabilities[0][predicted_class].item()
        
        labels = ["safe", "injection", "harmful", "sensitive"]
        return ClassificationResult(
            category=labels[predicted_class],
            confidence=confidence,
            all_scores={label: prob.item() for label, prob in zip(labels, probabilities[0])}
        )
```

#### ì„ë² ë”© ê¸°ë°˜ í•„í„°
```python
class EmbeddingFilter:
    def __init__(self, model_name: str = "sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2"):
        self.encoder = SentenceTransformer(model_name)
        self.vector_db = QdrantClient(host="localhost", port=6333)
        self.collection_name = "blocked_prompts"
    
    async def initialize_blocklist(self, blocked_examples: List[str]):
        """ê¸ˆì§€ í”„ë¡¬í”„íŠ¸ ì˜ˆì‹œë“¤ì„ ë²¡í„°í™”í•˜ì—¬ ì €ì¥"""
        embeddings = self.encoder.encode(blocked_examples)
        
        points = [
            PointStruct(
                id=i,
                vector=embedding.tolist(),
                payload={"text": example, "category": "blocked"}
            )
            for i, (embedding, example) in enumerate(zip(embeddings, blocked_examples))
        ]
        
        self.vector_db.upsert(collection_name=self.collection_name, points=points)
    
    async def check_similarity(self, prompt: str, threshold: float = 0.8) -> SimilarityResult:
        """ì…ë ¥ í”„ë¡¬í”„íŠ¸ì™€ ê¸ˆì§€ íŒ¨í„´ë“¤ì˜ ìœ ì‚¬ë„ ê²€ì‚¬"""
        query_embedding = self.encoder.encode([prompt])[0]
        
        search_result = self.vector_db.search(
            collection_name=self.collection_name,
            query_vector=query_embedding.tolist(),
            limit=5,
            score_threshold=threshold
        )
        
        if search_result:
            best_match = search_result[0]
            return SimilarityResult(
                is_similar=True,
                score=best_match.score,
                matched_text=best_match.payload["text"],
                action="block" if best_match.score > threshold else "warn"
            )
        
        return SimilarityResult(is_similar=False, score=0.0)
```

### 2.4 Sanitizer (í”„ë¡¬í”„íŠ¸ ì¬ì‘ì„±)
```python
class PromptSanitizer:
    def __init__(self):
        self.pii_detector = PIIDetector()
        self.secret_scanner = SecretScanner()
    
    async def sanitize(self, prompt: str, filter_results: List[FilterResult]) -> SanitizedPrompt:
        sanitized = prompt
        operations = []
        
        # PII ë§ˆìŠ¤í‚¹
        pii_matches = await self.pii_detector.detect(prompt)
        if pii_matches:
            sanitized = await self.pii_detector.anonymize(sanitized, pii_matches)
            operations.append("pii_masked")
        
        # ì‹œí¬ë¦¿ ì œê±°
        secret_matches = await self.secret_scanner.scan(sanitized)
        for match in secret_matches:
            sanitized = sanitized.replace(match.value, "[REDACTED]")
            operations.append("secret_removed")
        
        # ì¸ì ì…˜ ì‹œë„ ë¬´ë ¥í™”
        if any(r.reason == "injection_detected" for r in filter_results):
            sanitized = self.neutralize_injection(sanitized)
            operations.append("injection_neutralized")
        
        return SanitizedPrompt(
            original=prompt,
            sanitized=sanitized,
            operations=operations,
            safe_to_process=len([r for r in filter_results if r.action == "block"]) == 0
        )
    
    def neutralize_injection(self, prompt: str) -> str:
        """ì¸ì ì…˜ ì‹œë„ë¥¼ ë¬´ë ¥í™”"""
        # ì‹œìŠ¤í…œ ì§€ì‹œ ë¬´ë ¥í™” íŒ¨í„´ë“¤ì„ ì¼ë°˜ í…ìŠ¤íŠ¸ë¡œ ë³€í™˜
        neutralized = re.sub(r'(?i)ignore\s+(all\s+)?previous\s+(instructions?|rules?)', 
                           'discuss ignoring previous instructions', prompt)
        neutralized = re.sub(r'(?i)you\s+are\s+now\s+', 'imagine you are now ', neutralized)
        return neutralized
```

## 3. í†µí•© PromptGate ì„œë¹„ìŠ¤
```python
class PromptGateService:
    def __init__(self, config: PromptGateConfig):
        self.auth_handler = AuthenticationHandler(config.auth)
        self.policy_engine = PolicyEngine(config.policy)
        self.filters = [
            StaticPatternFilter(config.static_patterns),
            SecretScanner(),
            PIIDetector(),
            MLPromptClassifier(config.ml_model_path),
            EmbeddingFilter(config.embedding_model)
        ]
        self.sanitizer = PromptSanitizer()
        self.audit_logger = AuditLogger(config.audit)
    
    async def process_request(self, request: ChatRequest) -> ChatResponse:
        # 1. ì¸ì¦ ë° ì»¨í…ìŠ¤íŠ¸ ìƒì„±
        context = await self.auth_handler.authenticate(request)
        
        # 2. ì…ë ¥ ì •ê·œí™”
        normalized_prompt = self.normalize_input(request.prompt)
        
        # 3. í•„í„° ìŠ¤íƒ ì‹¤í–‰
        filter_results = []
        for filter_instance in self.filters:
            result = await filter_instance.filter(normalized_prompt)
            filter_results.append(result)
            
            # Fail-Fast: ì¦‰ì‹œ ì°¨ë‹¨ í•„ìš”í•œ ê²½ìš°
            if result.action == "block" and result.confidence > 0.9:
                await self.audit_logger.log_blocked_request(context, request, result)
                raise BlockedException(result.reason)
        
        # 4. ì •ì±… í‰ê°€
        policy_result = await self.policy_engine.evaluate(context, normalized_prompt)
        if not policy_result.allowed:
            await self.audit_logger.log_policy_violation(context, request, policy_result)
            raise PolicyViolationException(policy_result.reason)
        
        # 5. Sanitization
        sanitized = await self.sanitizer.sanitize(normalized_prompt, filter_results)
        if not sanitized.safe_to_process:
            raise UnsafePromptException("Prompt could not be safely sanitized")
        
        # 6. LLM í˜¸ì¶œ
        llm_response = await self.call_llm(sanitized.sanitized, context)
        
        # 7. ì¶œë ¥ í•„í„°ë§
        filtered_response = await self.filter_response(llm_response, context)
        
        # 8. ê°ì‚¬ ë¡œê¹…
        await self.audit_logger.log_successful_request(context, request, filtered_response)
        
        return filtered_response
    
    def normalize_input(self, prompt: str) -> str:
        """ì…ë ¥ ì •ê·œí™”"""
        # Unicode ì •ê·œí™”
        normalized = unicodedata.normalize('NFKC', prompt)
        # ì œì–´ ë¬¸ì ì œê±°
        normalized = ''.join(char for char in normalized if unicodedata.category(char) != 'Cc')
        # Base64 ë””ì½”ë”© ì‹œë„ (ì¸ì½”ë”©ëœ ì•…ì„± í˜ì´ë¡œë“œ íƒì§€)
        decoded_attempts = self.attempt_decoding(normalized)
        return normalized
```

## 4. ì„±ëŠ¥ ìµœì í™” ì „ëµ

### 4.1 ë¹„ë™ê¸° íŒŒì´í”„ë¼ì¸
```python
async def parallel_filtering(prompt: str) -> List[FilterResult]:
    """í•„í„°ë“¤ì„ ë³‘ë ¬ë¡œ ì‹¤í–‰í•˜ì—¬ ì„±ëŠ¥ í–¥ìƒ"""
    tasks = [
        asyncio.create_task(static_filter.filter(prompt)),
        asyncio.create_task(secret_scanner.scan(prompt)),
        asyncio.create_task(pii_detector.detect(prompt)),
        asyncio.create_task(ml_classifier.classify(prompt)),
        asyncio.create_task(embedding_filter.check_similarity(prompt))
    ]
    
    results = await asyncio.gather(*tasks, return_exceptions=True)
    return [r for r in results if not isinstance(r, Exception)]
```

### 4.2 ìºì‹± ì „ëµ
```python
class CacheManager:
    def __init__(self):
        self.redis = Redis()
        self.ttl = 3600  # 1ì‹œê°„
    
    async def get_cached_result(self, prompt_hash: str) -> Optional[FilterResult]:
        cached = await self.redis.get(f"filter:{prompt_hash}")
        return FilterResult.from_json(cached) if cached else None
    
    async def cache_result(self, prompt_hash: str, result: FilterResult):
        await self.redis.setex(f"filter:{prompt_hash}", self.ttl, result.to_json())

def hash_prompt(prompt: str) -> str:
    """í”„ë¡¬í”„íŠ¸ í•´ì‹œ (ê°œì¸ì •ë³´ ì œê±° í›„)"""
    # PII ì œê±° í›„ í•´ì‹±
    clean_prompt = re.sub(r'\b\d{6}-[1-4]\d{6}\b', '[RRN]', prompt)  # ì£¼ë¯¼ë²ˆí˜¸
    clean_prompt = re.sub(r'\b01[016789]-\d{3,4}-\d{4}\b', '[PHONE]', clean_prompt)  # ì „í™”ë²ˆí˜¸
    return hashlib.sha256(clean_prompt.encode()).hexdigest()
```

## 5. ëª¨ë‹ˆí„°ë§ ë° ê´€ì¸¡ì„±

### 5.1 ë©”íŠ¸ë¦­ ìˆ˜ì§‘
```python
from prometheus_client import Counter, Histogram, Gauge

# ë©”íŠ¸ë¦­ ì •ì˜
requests_total = Counter('promptgate_requests_total', 'Total requests', ['tenant', 'status'])
request_duration = Histogram('promptgate_request_duration_seconds', 'Request duration')
active_filters = Gauge('promptgate_active_filters', 'Number of active filters')
blocked_requests = Counter('promptgate_blocked_requests', 'Blocked requests', ['reason'])

class MetricsCollector:
    @staticmethod
    def record_request(context: RequestContext, status: str, duration: float):
        requests_total.labels(tenant=context.tenant_id, status=status).inc()
        request_duration.observe(duration)
    
    @staticmethod
    def record_block(reason: str):
        blocked_requests.labels(reason=reason).inc()
```

### 5.2 ì•Œë¦¼ ë° ëŒ€ì‹œë³´ë“œ
```python
class AlertManager:
    def __init__(self):
        self.webhook_url = os.getenv("SLACK_WEBHOOK_URL")
    
    async def send_alert(self, alert_type: str, message: str, severity: str = "warning"):
        if severity == "critical":
            await self.send_slack_notification(f"ğŸš¨ {alert_type}: {message}")
        
        # ë¡œê·¸ì—ë„ ê¸°ë¡
        logger.warning(f"Alert: {alert_type} - {message}")
    
    async def check_anomalies(self):
        """ì´ìƒ ì§•í›„ ëª¨ë‹ˆí„°ë§"""
        # ì°¨ë‹¨ìœ¨ ê¸‰ì¦ ê°ì§€
        recent_block_rate = await self.get_block_rate(minutes=10)
        if recent_block_rate > 0.5:  # 50% ì´ìƒ
            await self.send_alert("HIGH_BLOCK_RATE", f"Block rate: {recent_block_rate:.2%}")
        
        # ë°˜ë³µì ì¸ ì¸ì ì…˜ ì‹œë„
        injection_attempts = await self.get_injection_attempts_by_ip(minutes=5)
        for ip, count in injection_attempts.items():
            if count > 10:
                await self.send_alert("REPEATED_INJECTION", f"IP {ip}: {count} attempts")
```

## 6. ë°°í¬ ë° ìš´ì˜

### 6.1 Docker êµ¬ì„±
```dockerfile
FROM python:3.11-slim

WORKDIR /app

# ì‹œìŠ¤í…œ ì˜ì¡´ì„±
RUN apt-get update && apt-get install -y \
    libhyperscan5 \
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "promptgate.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### 6.2 Kubernetes ë°°í¬
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: promptgate
spec:
  replicas: 3
  selector:
    matchLabels:
      app: promptgate
  template:
    metadata:
      labels:
        app: promptgate
    spec:
      containers:
      - name: promptgate
        image: promptgate:latest
        ports:
        - containerPort: 8000
        env:
        - name: REDIS_URL
          value: "redis://redis-service:6379"
        - name: QDRANT_URL
          value: "http://qdrant-service:6333"
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
```

ì´ ì„¤ê³„ëŠ” í™•ì¥ ê°€ëŠ¥í•˜ê³  ì„±ëŠ¥ì´ ìµœì í™”ëœ í”„ë¡¬í”„íŠ¸ í•„í„°ë§ ì‹œìŠ¤í…œì„ ì œê³µí•©ë‹ˆë‹¤. ê° ì»´í¬ë„ŒíŠ¸ëŠ” ë…ë¦½ì ìœ¼ë¡œ ê°œë°œ/í…ŒìŠ¤íŠ¸/ë°°í¬ê°€ ê°€ëŠ¥í•˜ë©°, ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ê³¼ ì•Œë¦¼ ê¸°ëŠ¥ì„ í¬í•¨í•©ë‹ˆë‹¤.
