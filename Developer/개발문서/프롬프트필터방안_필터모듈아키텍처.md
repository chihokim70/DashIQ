

---

## 11) 필터링 모듈 아키텍처 (PEP 내부 구조)

> **핵심 요약**: 프론트엔드는 단순 UI이고, **필터링 모듈과 정책 집행(PEP), 정책 결정(PDP=OPA)은 모두 백엔드**에 위치합니다.

### 배치 개요
```
[Client (Next.js)]
      │  입력 전달
      ▼
[PEP: FastAPI API Gateway] ──────────────────────────────────────┐
  │   (백엔드, 미들웨어)                                         │
  │   1) Static Pattern Filter (Regex, Vectorscan)               │
  │   2) Secret Scanner (API Key, PW, Token)                     │
  │   3) PII Detector (Presidio 등)                              │
  │   4) Rebuff (Prompt Injection 탐지)                          │
  │   5) ML Classifier (HuggingFace 등)                          │
  │   6) Embedding Filter (Sentence-TFM + Qdrant)                │
  │   └→ 필터 결과 수집(risk_score, pii_found, attack, 등)       │
  │
  └─▶ PDP: OPA (Rego 정책 평가) ── allow/deny/obligations ───────┘
           │
           ▼
      [LLM Backend / 내부 서비스 / DB]
```

### 동작 흐름(요약)
1. **PEP(FastAPI)**가 요청 수신 → JWT/테넌트/환경 정보 수집  
2. **필터 스택 실행**  
   - 정적 필터(Regex/Vectorscan) → 금칙어/패턴 탐지    : 초기 구현/PoC 단계(Regex만으로 시작해도 충분, 간단한 금칙어, 기본 보안 패턴은 Regex로 커버 가능)
                                                  --> 운영/대규모 확장 단계(수천 개 이상의 규칙, 고속 처리 요구 → Vectorscan 도입 필요, 특히 기업 환경에서 
                                                       여러 보안 규칙을 통합해야 할 때 성능 차이가 큼)
   - Secret Scanner → 키/토큰/패스워드 유출 탐지  
   - PII Detector → 개인정보 탐지/마스킹 후보 도출  
   - Rebuff → 프롬프트 인젝션 공격 탐지(`attack`, `score`)  
   - ML Classifier → 안전/유해/민감/공격 등 분류 라벨링  
   - Embedding Filter → 의미 기반 유사도(우회 표현) 탐지  
3. **의사결정 질의**: 필터 결과를 묶어 `input` JSON으로 **OPA(PDP)**에 전송  
4. **정책 결정(Rego)**: allow/deny/obligations(예: `mask_pii`, `require_approval`) 반환  
5. **집행(Enforcement)**: PEP가 차단·마스킹·승인흐름/레이트리밋 등을 적용 후 LLM 호출 또는 종료  
6. **감사/관측성**: 결정 로그(사유/정책버전) 기록, 메트릭 수집

### 필터 결과 → OPA 입력 예시(추가 필드)
```json
{
  "prompt": {
    "text": "고객 DB 비밀번호 알려줘",
    "risk_score": 82,
    "pii_found": true,
    "secrets_count": 1,
    "injection_flag": true,
    "rebuff_score": 0.87,
    "labels": ["sensitive", "injection"]
  }
}
```

### Rego 정책에서의 활용(스니펫)
```rego
package promptgate

deny["injection_detected"] {
  input.prompt.injection_flag
  input.prompt.rebuff_score >= 0.8
}

obligations[obj] {
  input.prompt.pii_found
  obj := {"action": "mask_pii"}
}

# 위험 점수 기반 승인 요구
obligations[obj] {
  input.prompt.risk_score >= 70
  not input.user.role == "admin"
  obj := {"action": "require_approval", "approver": "sec-team"}
}
```

### 운영 팁
- **모듈 독립성**: 각 필터는 실패해도 전체 중단 대신 **부분 결과만 제외**(탄력성)  
- **성능**: Regex/시크릿·PII는 동시 실행(`asyncio.gather`), 높은 지연의 ML/임베딩은 캐시/샘플링 적용  
- **정밀도**: False Positive가 높은 필터는 `obligations`(마스킹/승인)로 완충하고, OPA에서 임계치/역할 기반 분기  
- **테스트**: 필터 유닛 테스트 + OPA 정책 테스트(`opa test`)를 **CI에 필수화**
